<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Speed Reading Chat - Mobile Optimized</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Using Tailwind CDN for single HTML file - acceptable for this use case -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #000000;
            color: #ffffff;
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden;
        }
        
        .word-display {
            font-size: 2.5rem;
            line-height: 1.2;
            font-family: 'Arial', sans-serif;
            text-align: left;
            padding: 0 1rem;
        }
        
        .word-display strong {
            font-weight: 800 !important;
            color: #f59e0b !important;
        }
        
        @media (max-width: 768px) {
            .word-display {
                font-size: 2rem;
            }
        }
        
        .touch-zone {
            position: absolute;
            top: 0;
            height: 100%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .touch-zone-left {
            left: 0;
            width: 33.33%;
        }
        
        .touch-zone-center {
            left: 33.33%;
            width: 33.33%;
        }
        
        .touch-zone-right {
            left: 66.66%;
            width: 33.33%;
        }
        
        .touch-zone:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }
        
        .settings-panel {
            position: fixed;
            top: 0;
            right: -100%;
            width: 100%;
            max-width: 400px;
            height: 100vh;
            background-color: #1a1a1a;
            transition: right 0.3s ease;
            z-index: 1000;
            overflow-y: auto;
        }
        
        .settings-panel.open {
            right: 0;
        }
        
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        
        .overlay.open {
            opacity: 1;
            visibility: visible;
        }
        
        .input-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: #1a1a1a;
            padding: 1rem;
            border-top: 1px solid #333;
        }
        
        .reading-area {
            position: fixed;
            top: 60px;
            left: 0;
            right: 0;
            bottom: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }
        
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background-color: #1a1a1a;
            border-bottom: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 1rem;
            z-index: 100;
        }
        
        .fast-actions {
            position: fixed;
            bottom: 80px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.5rem;
            background-color: rgba(26, 26, 26, 0.9);
        }
        
        .action-btn {
            background-color: #374151;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .action-btn:hover {
            background-color: #4b5563;
        }
        
        .action-btn:active {
            background-color: #1f2937;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        function ErrorBoundary({ children }) {
            const [hasError, setHasError] = useState(false);
            
            if (hasError) {
                return (
                    <div className="min-h-screen bg-black text-white p-4 flex items-center justify-center">
                        <div className="text-center">
                            <h1 className="text-2xl font-bold mb-4">Something went wrong</h1>
                            <button 
                                onClick={() => window.location.reload()} 
                                className="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded"
                            >
                                Reload Page
                            </button>
                        </div>
                    </div>
                );
            }
            
            return children;
        }

        function SpeedReadingChat() {
            const [apiKey, setApiKey] = useState('');
            const [message, setMessage] = useState('');
            const [chatHistory, setChatHistory] = useState([]);
            const [isLoading, setIsLoading] = useState(false);
            const [currentWord, setCurrentWord] = useState('');
            const [wordIndex, setWordIndex] = useState(0);
            const [currentSentence, setCurrentSentence] = useState([]);
            const [sentenceIndex, setSentenceIndex] = useState(0);
            const [isReading, setIsReading] = useState(false);
            const [alignment, setAlignment] = useState('left');
            const [wordDuration, setWordDuration] = useState(200);
            const [showSettings, setShowSettings] = useState(false);
            const [debugLog, setDebugLog] = useState([]);
            const [apiStatus, setApiStatus] = useState('idle');
            const [lastApiResponse, setLastApiResponse] = useState(null);
            const [lastApiError, setLastApiError] = useState(null);
            const [isDemoMode, setIsDemoMode] = useState(true);
            const [demoText, setDemoText] = useState('');
            const [autoAdvance, setAutoAdvance] = useState(false);
            const [fontSize, setFontSize] = useState(2.5);
            const [fontColor, setFontColor] = useState('#ffffff');
            const [boldColor, setBoldColor] = useState('#f59e0b');
            
            const wordTimeoutRef = useRef(null);
            const chatContainerRef = useRef(null);
            const lastTapTimeRef = useRef(0);
            const tapCountRef = useRef(0);

            const addDebugLog = (message, type = 'info') => {
                const timestamp = new Date().toLocaleTimeString();
                setDebugLog(prev => [...prev, { timestamp, message, type }]);
            };

            const testApiConnection = async () => {
                if (!apiKey) {
                    addDebugLog('No API key provided', 'error');
                    return false;
                }

                setApiStatus('loading');
                addDebugLog('Testing API connection...', 'info');

                try {
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            contents: [{
                                parts: [{
                                    text: 'Hello'
                                }]
                            }]
                        })
                    });

                    const data = await response.json();
                    
                    if (response.ok && data.candidates) {
                        setApiStatus('success');
                        addDebugLog('API connection successful', 'success');
                        setLastApiResponse(data);
                        return true;
                    } else {
                        setApiStatus('error');
                        setLastApiError(data);
                        addDebugLog(`API Error: ${data.error?.message || 'Unknown error'}`, 'error');
                        return false;
                    }
                } catch (error) {
                    setApiStatus('error');
                    setLastApiError({ error: { message: error.message } });
                    addDebugLog(`Network Error: ${error.message}`, 'error');
                    return false;
                }
            };

            const calculateWordDuration = (word) => {
                if (word.includes(' ')) {
                    const words = word.split(' ');
                    let totalDuration = 0;
                    for (const singleWord of words) {
                        totalDuration += calculateWordDuration(singleWord);
                    }
                    return totalDuration;
                }
                
                const baseDurationPerChar = wordDuration / 5;
                let duration = word.length * baseDurationPerChar;
                
                let punctuationPause = 0;
                if (word.match(/[.!?]/)) {
                    punctuationPause = 1000;
                } else if (word.match(/[,;]/)) {
                    punctuationPause = 600;
                } else if (word.match(/[:'"()]/)) {
                    punctuationPause = 400;
                }
                
                return duration + punctuationPause;
            };

            const applyFixation = (word) => {
                try {
                    if (!word || typeof word !== 'string') {
                        return word || '';
                    }
                    
                    if (word.includes(' ')) {
                        const words = word.split(' ');
                        return words.map(singleWord => applyFixation(singleWord)).join(' ');
                    }
                    
                    const length = word.length;
                    let boldCount = 0;
                    
                    if (length <= 3) {
                        boldCount = 1;
                    } else if (length === 4) {
                        boldCount = 2;
                    } else if (length === 5) {
                        boldCount = 2;
                    } else if (length === 6) {
                        boldCount = 3;
                    } else if (length > 6) {
                        boldCount = 4;
                    } 
                    
                    let boldIndices = [];
                    for (let i = 0; i < boldCount; i++) {
                        boldIndices.push(i);
                    }
                    
                    let result = '';
                    for (let i = 0; i < length; i++) {
                        if (boldIndices.includes(i)) {
                            result += `<strong>${word[i]}</strong>`;
                        } else {
                            result += word[i];
                        }
                    }
                    
                    return result;
                } catch (error) {
                    console.error('Error in applyFixation:', error);
                    return word || '';
                }
            };

            const displayNextWord = () => {
                if (currentSentence.length > 0 && sentenceIndex < currentSentence.length) {
                    const currentSentenceText = currentSentence[sentenceIndex];
                    const words = currentSentenceText.split(/\s+/).filter(word => word.trim());
                    
                    if (wordIndex === 0) {
                        addDebugLog(`Sentence words: [${words.map(w => `"${w}"`).join(', ')}]`, 'info');
                    }
                    
                    if (wordIndex < words.length) {
                        let word = words[wordIndex];
                        let combinedWord = word;
                        let skipNext = false;
                        
                        addDebugLog(`Processing word ${wordIndex}: "${word}"`, 'info');
                        
                        if (word.match(/^[.!?,;:'"()]+$/)) {
                            addDebugLog(`Found punctuation: "${word}"`, 'info');
                            if (wordIndex > 0) {
                                const prevWord = words[wordIndex - 1];
                                combinedWord = prevWord + word;
                                setCurrentWord(combinedWord);
                                const duration = calculateWordDuration(combinedWord);
                                addDebugLog(`Combined punctuation: "${prevWord}" + "${word}" = "${combinedWord}"`, 'info');
                                
                                wordTimeoutRef.current = setTimeout(() => {
                                    setWordIndex(prev => prev + 1);
                                }, duration);
                                return;
                            }
                        }
                        
                        if (word.length <= 2 && wordIndex + 1 < words.length) {
                            const nextWord = words[wordIndex + 1];
                            if (!nextWord.match(/^[.!?,;:'"()]+$/)) {
                                combinedWord = word + ' ' + nextWord;
                                skipNext = true;
                                addDebugLog(`Combined: "${word}" + "${nextWord}" = "${combinedWord}"`, 'info');
                            }
                        }
                        
                        setCurrentWord(combinedWord);
                        const duration = calculateWordDuration(combinedWord);
                        
                        addDebugLog(`Word: "${combinedWord}" (${combinedWord.length} chars) - Duration: ${duration}ms`, 'info');
                        
                        wordTimeoutRef.current = setTimeout(() => {
                            setWordIndex(prev => prev + (skipNext ? 2 : 1));
                        }, duration);
                    } else {
                        // End of sentence - pause here unless auto-advance is enabled
                        if (autoAdvance) {
                            setSentenceIndex(prev => prev + 1);
                            setWordIndex(0);
                            if (sentenceIndex + 1 >= currentSentence.length) {
                                setIsReading(false);
                                setCurrentWord('');
                                setSentenceIndex(0);
                                setWordIndex(0);
                            }
                        } else {
                            // Pause at end of sentence
                            setIsReading(false);
                        }
                    }
                } else {
                    setIsReading(false);
                    setCurrentWord('');
                    setSentenceIndex(0);
                    setWordIndex(0);
                }
            };

            useEffect(() => {
                if (isReading && currentSentence.length > 0) {
                    displayNextWord();
                }
                
                return () => {
                    if (wordTimeoutRef.current) {
                        clearTimeout(wordTimeoutRef.current);
                    }
                };
            }, [isReading, wordIndex, sentenceIndex, currentSentence]);

            useEffect(() => {
                if (chatContainerRef.current) {
                    chatContainerRef.current.scrollTop = chatContainerRef.current.scrollHeight;
                }
            }, [chatHistory]);

            useEffect(() => {
                const startDanteReading = () => {
                    const sampleTexts = getSampleTexts();
                    const danteText = sampleTexts[0].text;
                    
                    const sentences = danteText.split(/(?<=[.!?])\s+/).filter(s => s.trim());
                    setCurrentSentence(sentences);
                    setSentenceIndex(0);
                    setWordIndex(0);
                    setIsReading(true);
                    setCurrentWord('');
                    
                    addDebugLog(`Started reading with ${sentences.length} sentences`, 'info');
                };
                
                startDanteReading();
            }, []);

            const getSampleTexts = () => [
                {
                    title: "Il Sentiero dei Nidi di Ragno",
                    text: "Per arrivare fino in fondo al vicolo, i raggi del sole devono scendere diritti rasente le pareti fredde, tenute discoste a forza d'arcate che traversano la striscia di cielo azzurro carico. Scendono diritti, i raggi del sole, giù per le finestre messe qua e là in disordine sui muri, e cespi di basilico e di origano piantati dentro pentole ai davanzali, e sottovesti stese appese a corde; fin giù al selciato, fatto a gradini e a ciottoli, con una cunetta in mezzo per l'orina dei muli. Basta un grido di Pin, un grido per incominciare una canzone, a naso all'aria sulla soglia della bottega, o un grido cacciato prima che la mano di Pietromagro il ciabattino gli sia scesa tra capo e collo per picchiarlo, perché dai davanzali nasca un'eco di richiami e d'insulti. - Pin! Già a quest'ora cominci ad angosciarci! Cantacene un po' una, Pin!    Pin, meschinetto, cosa ti fanno? Pin, muso di macacco! Ti si seccasse la voce in gola, una volta! Tu e quel rubagalline del tuo padrone! Tu e quel materasso di tua sorella! Ma già Pin è in mezzo al carrugio, con le mani nelle tasche della giacca troppo da uomo per lui, che li guarda in faccia uno per uno senza ridere:  - Di' Celestino, sta' un po' zitto, bel vestito nuovo che hai. E-di', quel furto di stoffa ai Moli Nuovi, poi, non si sa ancora chi sia stato? Be', che c'entra. Ciao Carolina, meno male quella volta. Si, quella volta meno male tuo marito che non ha guardato sotto il letto. Anche tu, Pasca, m'han detto che è successo proprio al tuo paese. Sì, che Garibaldi ci ha portato il sapone e i tuoi paesani se lo son mangiato. Mangiasapone, Pasca, mondoboia, lo sapete quanto costa il sapone? Pin ha una voce rauca da bambino vecchio: dice ogni battuta a bassa voce, serio, poi tutt'a un tratto sbotta in una risata in i che sembra un fischio e le lentiggini rosse e nere gli si affollano intorno agli occhi come un volo di vespe. A canzonare Pin c'è sempre da rimettere: conosce tutti i fatti del carrugio e non si sa mai cosa va a tirar fuori. Mattina e sera sotto le finestre a sgolarsi in canzoni e in gridi, mentre nella bottega di Pietromagro la montagna di scarpe sfondate tra poco seppellisce il deschetto e trabocca in istrada.    - Pin! Macacco! Muso brutto! - gli grida qualche donna. - Mi risuolassi quelle ciabatte invece di starci ad angosciare tutto il giorno! È un mese che le avete lì nel mucchio. Lo dirò un po' io al tuo padrone, quando lo metteranno fuori! Pietromagro passa metà dell'anno in prigione, perché è nato disgraziato e quando c'è un furto nei dintorni finiscono sempre per mettere dentro lui. Torna e vede la montagna di scarpe sfondate e la bottega aperta senza dentro nessuno. Allora si siede al deschetto, piglia una scarpa, la gira, la rigira, la ributta nel mucchio; poi si prende la faccia pelosa tra le mani ossute, e sacramenta. Pin arriva fischiando e ancora non sa niente: ed ecco che si trova davanti Pietromagro con quelle mani già alte nell'aria e quelle pupille incorniciate di giallo e quella faccia nera di barba corta come pelo di cane. Grida, ma Pietromagro l'ha acciuffato e non lo molla; quando è stanco di picchiarlo lo lascia in bottega e s'infila all'osteria. Per quel giorno nessuno lo rivede.    La sera, ogni due giorni, dalla sorella di Pin viene il marinaio tedesco. Pin lo aspetta nel carrugio ogni volta mentre sale, per chiedergli una sigaretta; i primi tempi era generoso e ne regalava anche tre, quattro per volta. Prendere in giro il marinaio tedesco è facile perché lui non capisce e guarda con quella faccia quagliata, senza contorno, rasa fin sulle tempie. Poi, quando se n'è andato, gli si possono fare gli sberleffi dietro, sicuri che non si volta; è ridicolo visto di dietro, con quei due nastri neri che gli scendono dal berretto marinaio fino al sedere lasciato scoperto dal giubbetto corto, un sedere carnoso, da donna, con una grossa pistola tedesca poggiata sopra. - Ruffiano... Ruffiano... - dice la gente a Pin dalle finestre, sottovoce perché con quei tipi è meglio non scherzare.    - Cornuti... Cornuti... -  risponde Pin facendo loro il verso e ingozzandosi di fumo gola e naso, fumo ancora aspro e ruvido contro la sua gola di bambino, ma di cui bisogna ingozzarsi fino a farsi lagrimare gli occhi e tossire con rabbia, non si sa bene il perché. Poi, con la sigaretta in bocca, andare all'osteria e dire: - Mondoboia, chi mi paga un bicchiere gli dico una cosa che poi mi dice grazie. All'osteria ci sono sempre gli stessi, tutt'il giorno, da anni, a gomiti sui tavoli e menti sui pugni che guardano le mosche sull'incerato e l'ombra viola in fondo ai bicchieri.     - Che c'è, - dice Miscèl il Francese. - Tua sorella ha ribassato i prezzi?  Gli altri ridono e picchiano pugni sullo zinco. - Te la sei presa questa volta, Pin, la risposta! Pin è li che lo guarda di sotto in su attraverso la frangia di capelli spinosi che gli mangia la fronte.    - Mondoboia, proprio come pensavo io. Guardate un poco, pensa sempre a mia sorella. Vi dico, non smette mai di pensarci: s'è innamorato. Di mia sorella s'è innamorato, che coraggio...    Gli altri ridono a gola spiegata e lo scappellottano e gli versano un bicchiere. Il vino non piace a Pin: è aspro contro la gola e arriccia la pelle e mette addosso una smania di ridere, gridare ed essere cattivi. Pure lo beve, tracanna bicchieri tutto d'un fiato come inghiotte fumo, come alla notte spia con schifo la sorella sul letto insieme a uomini nudi, e il vederla è come una carezza ruvida, sotto la pelle, un gusto aspro, come tutte le cose degli uomini; fumo, vino, donne.    - Canta, Pin, - gli dicono. Pin canta bene, serio, impettito, con quella voce di bambino rauco. Canta Le quattro stagioni."
                }
            ];

            const sendMessage = async () => {
                if (!message.trim()) return;
                
                const userMessage = message.trim();
                setMessage('');
                setChatHistory(prev => [...prev, { role: 'user', content: userMessage }]);
                setIsLoading(true);
                
                if (isDemoMode) {
                    setTimeout(() => {
                        const sampleTexts = getSampleTexts();
                        const randomText = sampleTexts[Math.floor(Math.random() * sampleTexts.length)];
                        setChatHistory(prev => [...prev, { role: 'assistant', content: randomText.text }]);
                        setIsLoading(false);
                        
                        // Start reading the new text
                        const sentences = randomText.text.split(/(?<=[.!?])\s+/).filter(s => s.trim());
                        setCurrentSentence(sentences);
                        setSentenceIndex(0);
                        setWordIndex(0);
                        setIsReading(true);
                        setCurrentWord('');
                    }, 1000);
                } else {
                    try {
                        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                contents: [{
                                    parts: [{
                                        text: userMessage
                                    }]
                                }]
                            })
                        });

                        const data = await response.json();
                        
                        if (response.ok && data.candidates) {
                            const assistantMessage = data.candidates[0].content.parts[0].text;
                            setChatHistory(prev => [...prev, { role: 'assistant', content: assistantMessage }]);
                            setLastApiResponse(data);
                            
                            // Start reading the response
                            const sentences = assistantMessage.split(/(?<=[.!?])\s+/).filter(s => s.trim());
                            setCurrentSentence(sentences);
                            setSentenceIndex(0);
                            setWordIndex(0);
                            setIsReading(true);
                            setCurrentWord('');
                        } else {
                            setChatHistory(prev => [...prev, { role: 'assistant', content: `Error: ${data.error?.message || 'Unknown error'}` }]);
                            setLastApiError(data);
                        }
                    } catch (error) {
                        setChatHistory(prev => [...prev, { role: 'assistant', content: `Error: ${error.message}` }]);
                    }
                    
                    setIsLoading(false);
                }
            };

            const handleKeyPress = (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            };

            const handleNextSentence = () => {
                if (sentenceIndex < currentSentence.length - 1) {
                    setSentenceIndex(prev => prev + 1);
                    setWordIndex(0);
                    setIsReading(true);
                } else {
                    setIsReading(false);
                    setCurrentWord('');
                    setSentenceIndex(0);
                    setWordIndex(0);
                }
            };

            const handleRewindWords = () => {
                if (wordIndex > 5) {
                    setWordIndex(prev => prev - 5);
                } else {
                    setWordIndex(0);
                }
            };

            const handleRewindPhrase = () => {
                setWordIndex(0);
            };

            const handleRestartPhrase = () => {
                setWordIndex(0);
                setIsReading(true);
            };

            const handleTouchZone = (zone) => {
                const now = Date.now();
                const timeDiff = now - lastTapTimeRef.current;
                
                if (timeDiff < 300) {
                    tapCountRef.current++;
                } else {
                    tapCountRef.current = 1;
                }
                
                lastTapTimeRef.current = now;
                
                if (zone === 'left') {
                    if (tapCountRef.current >= 3) {
                        // Triple tap - rewind entire phrase
                        handleRewindPhrase();
                        addDebugLog('Triple tap left: Rewind entire phrase', 'info');
                    } else {
                        // Single tap - rewind 5 words
                        handleRewindWords();
                        addDebugLog('Single tap left: Rewind 5 words', 'info');
                    }
                } else {
                    // Center or right zone - next phrase
                    handleNextSentence();
                    addDebugLog(`Tap ${zone}: Next phrase`, 'info');
                }
            };

            const handleStartReading = () => {
                if (!isReading) {
                    setIsReading(true);
                }
            };

            return (
                <div className="h-screen bg-black text-white overflow-hidden">
                    {/* Header */}
                    <div className="header">
                        <h1 className="text-lg font-semibold">Speed Reader</h1>
                        <button
                            onClick={() => setShowSettings(!showSettings)}
                            className="bg-gray-700 hover:bg-gray-600 text-white px-3 py-1 rounded"
                        >
                            ⚙️ Settings
                        </button>
                    </div>

                    {/* Reading Area */}
                    <div className="reading-area">
                        <div 
                            className="word-display"
                            style={{
                                textAlign: alignment,
                                fontSize: `${fontSize}rem`,
                                color: fontColor
                            }}
                            dangerouslySetInnerHTML={{
                                __html: currentWord ? applyFixation(currentWord) : 'Tap to start reading...'
                            }}
                        />
                    </div>

                    {/* Touch Zones */}
                    <div 
                        className="touch-zone touch-zone-left"
                        onClick={() => handleTouchZone('left')}
                        onTouchStart={() => handleTouchZone('left')}
                    />
                    <div 
                        className="touch-zone touch-zone-center"
                        onClick={() => handleTouchZone('center')}
                        onTouchStart={() => handleTouchZone('center')}
                    />
                    <div 
                        className="touch-zone touch-zone-right"
                        onClick={() => handleTouchZone('right')}
                        onTouchStart={() => handleTouchZone('right')}
                    />

                    {/* Fast Actions */}
                    <div className="fast-actions">
                        <button onClick={handleNextSentence} className="action-btn">
                            ⏭️ Next Phrase
                        </button>
                        <button onClick={handleRewindWords} className="action-btn">
                            ⏪ Back 5 Words
                        </button>
                        <button onClick={handleRestartPhrase} className="action-btn">
                            🔄 Restart Phrase
                        </button>
                    </div>

                    {/* Input Bar */}
                    <div className="input-bar">
                        <div className="flex gap-2">
                            <input
                                type="text"
                                value={message}
                                onChange={(e) => setMessage(e.target.value)}
                                onKeyPress={handleKeyPress}
                                placeholder={isDemoMode ? "Type anything for sample text..." : "Type your message..."}
                                disabled={isLoading}
                                className="flex-1 p-3 bg-gray-800 border border-gray-600 rounded-lg text-white placeholder-gray-400 disabled:opacity-50"
                            />
                            <button
                                onClick={sendMessage}
                                disabled={isLoading || !message.trim()}
                                className="bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-semibold py-3 px-6 rounded-lg transition-colors"
                            >
                                {isLoading ? 'Sending...' : 'Send'}
                            </button>
                        </div>
                    </div>

                    {/* Settings Panel */}
                    <div className={`overlay ${showSettings ? 'open' : ''}`} onClick={() => setShowSettings(false)} />
                    <div className={`settings-panel ${showSettings ? 'open' : ''}`}>
                        <div className="p-6">
                            <div className="flex justify-between items-center mb-6">
                                <h2 className="text-xl font-bold">Settings</h2>
                                <button
                                    onClick={() => setShowSettings(false)}
                                    className="text-gray-400 hover:text-white"
                                >
                                    ✕
                                </button>
                            </div>

                            <div className="space-y-6">
                                {/* Speed Settings */}
                                <div>
                                    <h3 className="text-lg font-semibold mb-3">Speed</h3>
                                    <label className="block text-sm font-medium mb-2">
                                        Base Speed: {wordDuration}ms (per 5 chars)
                                    </label>
                                    <input
                                        type="range"
                                        min="100"
                                        max="1000"
                                        value={wordDuration}
                                        onChange={(e) => setWordDuration(parseInt(e.target.value))}
                                        className="w-full"
                                    />
                                </div>

                                {/* Auto Advance */}
                                <div>
                                    <label className="flex items-center">
                                        <input
                                            type="checkbox"
                                            checked={autoAdvance}
                                            onChange={(e) => setAutoAdvance(e.target.checked)}
                                            className="mr-2"
                                        />
                                        Auto advance to next phrase
                                    </label>
                                </div>

                                {/* Font Settings */}
                                <div>
                                    <h3 className="text-lg font-semibold mb-3">Font</h3>
                                    <div className="space-y-3">
                                        <div>
                                            <label className="block text-sm font-medium mb-1">Font Size: {fontSize}rem</label>
                                            <input
                                                type="range"
                                                min="1.5"
                                                max="4"
                                                step="0.1"
                                                value={fontSize}
                                                onChange={(e) => setFontSize(parseFloat(e.target.value))}
                                                className="w-full"
                                            />
                                        </div>
                                        <div>
                                            <label className="block text-sm font-medium mb-1">Font Color</label>
                                            <input
                                                type="color"
                                                value={fontColor}
                                                onChange={(e) => setFontColor(e.target.value)}
                                                className="w-full h-10 rounded"
                                            />
                                        </div>
                                        <div>
                                            <label className="block text-sm font-medium mb-1">Bold Color</label>
                                            <input
                                                type="color"
                                                value={boldColor}
                                                onChange={(e) => setBoldColor(e.target.value)}
                                                className="w-full h-10 rounded"
                                            />
                                        </div>
                                    </div>
                                </div>

                                {/* Alignment */}
                                <div>
                                    <h3 className="text-lg font-semibold mb-3">Alignment</h3>
                                    <div className="flex gap-2">
                                        {['left', 'center', 'right'].map((align) => (
                                            <button
                                                key={align}
                                                onClick={() => setAlignment(align)}
                                                className={`px-4 py-2 rounded ${
                                                    alignment === align 
                                                        ? 'bg-blue-600 text-white' 
                                                        : 'bg-gray-700 text-gray-300'
                                                }`}
                                            >
                                                {align.charAt(0).toUpperCase() + align.slice(1)}
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                {/* Demo Mode */}
                                <div>
                                    <label className="flex items-center">
                                        <input
                                            type="checkbox"
                                            checked={isDemoMode}
                                            onChange={(e) => setIsDemoMode(e.target.checked)}
                                            className="mr-2"
                                        />
                                        Demo Mode (sample texts)
                                    </label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(
            <ErrorBoundary>
                <SpeedReadingChat />
            </ErrorBoundary>
        );
    </script>
</body>
</html> 